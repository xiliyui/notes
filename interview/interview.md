**css问题**

一.link和@import都可以导入css样式，但是他们之间有什么区别？
区别：
1.link不仅可以导入样式表，还可以导入其他如如favicon，但@import只能导入样式表
2.link是html标签，不存在兼容问题，但是@import是在css2.1才提出，在IE5+后才支持，所以对低版本的浏览器不兼容
3.可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。
4.link是在页面加载的的同时一起加载的，@import是页面加载完毕后才加载的
5.link引入的样式权重大于@import引入的样式（有争议）

二.盒模型相关

①盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)

②类型： IE 盒子模型、标准 W3C 盒子模型；

③两种盒模型的主要区别是:标准盒模型的宽高是值内容宽高(content) 

④而IE盒模型的宽高是指content+padding+border。

⑤设置盒模型的方式是：设置box-sizing

  box-sizing:content-box 标准盒模型

  box-sizing:border-box IE盒模型

三.为什么要初始化css样式

因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没有对css初始化往往会出现浏览器之间的页面显示差异，例如{ margin: 0, padding: 0 }

四.BFC的理解

**BFC**(Block Formatting Context)块级格式化上下文，是用于布局块级盒子的一块渲染区域。[MDN上的解释](https://link.segmentfault.com/?enc=L%2BUkO4nYRc3XALr64QVcOw%3D%3D.H6kE0WmwhE7I4JWNOn9EH%2FIV6jqcql%2F%2ByRe7zNWI6cxsSoyapdhMrxGOYpUUBm78KOTpBKz8Ou22PHOMdHnHv11Vd2g1oQBQJCPYwA2ZPBg%3D)：BFC是Web页面 CSS 视觉渲染的一部分，用于决定块盒子的布局及浮动相互影响范围的一个区域。

BFC触发方式

1. 根元素，即HTML标签
2. 浮动元素：float值为`left`、`right`
3. overflow值不为 visible，为 `auto`、`scroll`、`hidden`
4. display值为 `inline-block`、`table-cell`、`table-caption`、`table`、`inline-table`、`flex`、`inline-flex`、`grid`、`inline-grid`
5. 定位元素：position值为 `absolute`、`fixed`

html部分

一.Doctype

DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是**告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义来解析文档**，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。

浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是**CSS1Compat**）：

- **CSS1Compat：标准模式（Standard mode）**，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。
- **BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。]

二.解释下浮动和它的工作原理？清除浮动的技巧

```
定义：浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。

1.使用空标签清除浮动。
   这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。
2.使用overflow。
   给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。
3.使用after伪对象清除浮动。
   该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；
```

三.src和href的区别

```javascript
src和href都是用来引用外部的资源，它们的区别如下：

src： 表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。
href： 表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。
```

四.对HTML语义化的理解

```javascript
语义化是指根据内容的结构化（内容语义化），选择合适的标签（代码语义化）。通俗来讲就是用正确的标签做正确的事情。
优点：
对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；
对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。
常见的语义化标签：
<header></header>  头部
<nav></nav>  导航栏
<section></section>  区块（有语义化的div）
<main></main>  主要区域
<article></article>  主要内容
<aside></aside>  侧边栏
<footer></footer>  底部
```

五.script标签中defer和async的区别

```javascript
如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。
defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析，其区别如下：
执行顺序：多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；
脚本是否并行执行：async属性，表示后续文档的加载和执行与js脚本的加载和执行是并行进行的，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。
```

六.常⽤的meta标签有哪些

`meta` 标签由 `name` 和 `content` 属性定义，**用来描述网页文档的属性**，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些`name`作为大家使用的共识，开发者还可以自定义name。

常用的meta标签： 

（1）`charset`，用来描述HTML文档的编码类型：

```html
<meta charset="UTF-8" >
复制代码
```

（2） `keywords`，页面关键词：

```html
<meta name="keywords" content="关键词" />
复制代码
```

（3）`description`，页面描述：

```html
<meta name="description" content="页面描述内容" />
复制代码
```

（4）`refresh`，页面重定向和刷新：

```html
<meta http-equiv="refresh" content="0;url=" />
复制代码
```

（5）`viewport`，适配移动端，可以控制视口的大小和比例：

```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
复制代码
```

其中，`content` 参数有以下几种：

- `width viewport` ：宽度(数值/device-width)
- `height viewport` ：高度(数值/device-height)
- `initial-scale` ：初始缩放比例
- `maximum-scale` ：最大缩放比例
- `minimum-scale` ：最小缩放比例
- `user-scalable` ：是否允许用户缩放(yes/no）

七.img的srcset属性的作⽤

响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：

```html
<img src="image-128.png" srcset="image-256.png 2x" />
复制代码
```

使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。

按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：

```html
<img src="image-128.png"
     srcset="image-128.png 128w, image-256.png 256w, image-512.png 512w"
     sizes="(max-width: 360px) 340px, 128px" />
复制代码
```

其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。

sizes语法如下：

```html
sizes="[media query] [length], [media query] [length] ... "
复制代码
```

sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。

js层面

一.iframe的优缺点？

```
（1）<iframe>优点：
    解决加载缓慢的第三方内容如图标和广告等的加载问题
    Security sandbox
    并行加载脚本
（2）<iframe>的缺点：
    *iframe会阻塞主页面的Onload事件；
    *即时内容为空，加载也需要时间
    *没有语意 
```

二.sessionStorage、localStorage和cookie的区别

共同点：都是保存在浏览器端、且同源的 
区别： 
1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 
2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 
3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 
4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 
5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 
6、web Storage的api接口使用更方便

三.线程与进程的区别

```
一个程序至少有一个进程,一个进程至少有一个线程. 
线程的划分尺度小于进程，使得多线程程序的并发性高。 
另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
```

四.你如何对网站的文件和资源进行优化？

```
 文件合并
 文件最小化/文件压缩
 使用 CDN 托管
 缓存的使用（多个域名来提供缓存）
 其他
```

五.请说出三种减少页面加载时间的方法。

```
 1.优化图片 
 2.图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方） 
 3.优化CSS（压缩合并css，如margin-top,margin-left...) 
 4.网址后加斜杠（如www.campr.com/目录，会判断这个“目录是什么文件类型，或者是目录。） 
 5.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 
当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。） 
6.减少http请求（合并文件，合并图片）。
```

六.null 和 undefined 基本同义，二者又有什么区别

**`null`表示没有对象，即该处不应该有值**

```javascript
1） 作为函数的参数，表示该函数的参数不是对象
2） 作为对象原型链的终点
```

**`undefined`表示缺少值，即此处应该有值，但没有定义**

```javascript
1）定义了形参，没有传实参，显示undefined
2）对象属性名不存在时，显示undefined
3）函数没有写返回值，即没有写return，拿到的是undefined
4）写了return，但没有赋值，拿到的是undefined
```

七.new操作符具体干了什么呢? 

1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。   2、属性和方法被加入到 this 引用的对象中。   3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。

```javascr
var obj  = {};
obj.__proto__ = Base.prototype;
Base.call(obj); 
```

八.javascript对象的几种创建方式以及继承的6种方法

```javascript
一）对象创建的几种方式
1，工厂模式
2，构造函数模式
3，原型模式
4，混合构造函数和原型模式
5，动态原型模式
6，寄生构造函数模式
7，稳妥构造函数模式
二）继承的6种方法
1，原型链继承
2，借用构造函数继承
3，组合继承(原型+借用构造)
4，原型式继承
5，寄生式继承
6，寄生组合式继承
```

九.ajax

```javascript
一）ajax过程
//1、创建对象，打开浏览器
var xhr=new XMLHttpRequest();
//2、在地址栏输入地址
xhr.open('post','1.txt',true);
//3、提交（发送请求）
xhr.send();
//4、等待服务器返回内容
xhr.onreadystatechange=function(){
  readyState属性：请求状态
//0 （初始化）还没有调用open()方法
//1 （载入）已调用send()方法，正在发送请求
//2 （载入完成）send()方法完成，已收到全部响应内容
//3 （解析）正在解析响应内容
//4 （完成）响应内容解析完成，可以在客户端调用了
  if (xhr.readyState==4) {
    if (xhr.status==200) {
      alert(xhr.responseText); 
    }else{
      alert("出错了:"+xhr.status);
    }
  };
}
二）优点
	1. 通过异步模式，提升了用户体验
  2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用
  3. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。
  最大的优点就是Ajax可以实现动态不刷新（局部刷新）
三）ajax的缺点
  1、ajax不支持浏览器back按钮。
  2、安全问题 AJAX暴露了与服务器交互的细节。
  3、对搜索引擎的支持比较弱。
  4、破坏了程序的异常机制。
  5、不容易调试。
```

十.js数组去重

```javascript
ES6中利用Set去重
建新数组，利用indexOf去重
for循环嵌套，利用splice去重
```

十一.cache-control

```javascript
网页的缓存是由HTTP消息头中的private、no-cache、max-age、must-revalidate等，默认为max-age的效果。但是如果同时存在，则被max-age覆盖。
Expires = "Expires" ":" HTTP-date
例如:Expires: Thu, 01 Dec 1994 16:00:00 GMT （必须是GMT格式）
如果把它设置为max-age都可以用来指定文档的过期时间，但是二者有一些细微差别
1.Expires在HTTP/1.0中已经定义，Cache-Control:max-age在HTTP/1.1中才有定义，为了向下兼容，仅使用max-age不够；
2.Expires指定一个绝对的过期时间(GMT格式),这么做会导致至少2个问题：1)客户端和服务器时间不同步导致Expires的配置出现问题。 2）很容易在配置后忘记具体的过期时间，导致过期来临出现浪涌现象；
3.max-age 指定的是从文档被访问后的存活时间，这个时间是个相对值(比如:3600s),相对的是文档第一次被请求时服务器记录的Request_time(请求时间)
4.Expires指定的时间可以是相对文件的最后访问时间(Atime)或者修改时间(MTime),而max-age相对对的是文档的请求时间(Atime)
如果值为no-cache,那么每次都会访问服务器。如果值为max-age,则在过期之前不会重复访问服务器。
```

十二.js延迟加载的方式有哪些(异步加载和延迟加载)？

```javascript
1.异步加载的方案： 动态插入script标签
2.通过ajax去获取js代码，然后通过eval执行
3.script标签上添加defer或者async属性
 	1)defer 属性   
  `defer`属性**只适用于外部脚本文件**,脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕之后再执行。
  `<script src='./index.js' defer='defer' ></script>`
	2)async 属性
	不让页面等待脚本下载和执行，从而**异步加载页面其他内容**。异步脚本一定会在页面 load 事件前执行。不能保证脚本会按顺序执行。
	`<script src='index.js' async></script>`
async和defer一样，都不会阻塞其他资源下载，所以不会影响页面的加载。
缺点：不能控制加载的顺序
4.创建并插入iframe，让它异步执行js
5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。
6、使用`setTimeout`延迟方法
7、把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度
3)动态创建DOM方式 `element.src='index.js'
```

十三.eval是做什么的？

```
它的功能是把对应的字符串解析成JS代码并运行；
应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
```

十四.this板块 

```javascript
this是Javascript语言的一个关键字。
随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。
一)this指向的形式4种
a.如果是一般函数,this指向全局对象window;
b.在严格模式下"use strict",为undefined.
c.对象的方法里调用,this指向调用该方法的对象.
d.构造函数里的this,指向创建出来的实例.
定义一个_this变量来存储this值,使全局对象里面的this 指向person 的this
this最近的函数是全局对象setTimeout
二）改变this指向的方式
.call(),  call(thisScope, arg1, arg2, arg3...)， 改变this指向后立刻调用函数
.apply(), apply(thisScope, [arg1, arg2, arg3...]); 返回的是函数
而bind 改变this的指向，返回的是函数
.bind()，  bind(thisScope, arg1, arg2, arg3...)返回的是函数
```

十五.哪些操作会造成内存泄漏？

```
定义：内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。
setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包也会造成内存泄露
```

十六.什么叫优雅降级和渐进增强？

```
优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。
渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
```

十七.你有哪些性能优化的方法？

```javascript
一)减少请求数量
【合并】
　　如果不进行文件合并，有如下3个隐患
　　1、文件与文件之间有插入的上行请求，增加了N-1个网络延迟
　　2、受丢包问题影响更严重
　　3、经过代理服务器时可能会被断开
　　但是，文件合并本身也有自己的问题
　　1、首屏渲染问题
　　2、缓存失效问题
　　所以，对于文件合并，有如下改进建议
　　1、公共库合并
　　2、不同页面单独合并
【图片处理】
　　1、雪碧图
　　CSS雪碧图是以前非常流行的技术，把网站上的一些图片整合到一张单独的图片中，可以减少网站的HTTP请求数量，但是当整合图片比较大时，一次加载比较慢。随着字体图片、SVG图片的流行，该技术渐渐退出了历史舞台
　　2、Base64
　　将图片的内容以Base64格式内嵌到HTML中，可以减少HTTP请求数量。但是，由于Base64编码用8位字符表示信息中的6个位，所以编码后大小大约比原始值扩大了 33%
　　3、使用字体图标来代替图片
【减少重定向】
　　尽量避免使用重定向，当页面发生了重定向，就会延迟整个HTML文档的传输。在HTML文档到达之前，页面中不会呈现任何东西，也没有任何组件会被下载，降低了用户体验
　　如果一定要使用重定向，如http重定向到https，要使用301永久重定向，而不是302临时重定向。因为，如果使用302，则每一次访问http，都会被重定向到https的页面。而永久重定向，在第一次从http重定向到https之后 ，每次访问http，会直接返回https的页面
【使用缓存】
　　使用cach-control或expires这类强缓存时，缓存不过期的情况下，不向服务器发送请求。强缓存过期时，会使用last-modified或etag这类协商缓存，向服务器发送请求，如果资源没有变化，则服务器返回304响应，浏览器继续从本地缓存加载资源；如果资源更新了，则服务器将更新后的资源发送到浏览器，并返回200响应
【不使用CSS @import】
　　CSS的@import会造成额外的请求
【避免使用空的src和href】
　　a标签设置空的href，会重定向到当前的页面地址
　　form设置空的method，会提交表单到当前的页面地址
二）减小资源大小
【压缩】
　　1、HTML压缩。HTML代码压缩就是压缩在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等。
　　2、CSS压缩。CSS压缩包括无效代码删除与CSS语义合并。
　　3、JS压缩与混乱。JS压缩与混乱包括无效字符及注释的删除、代码语义的缩减和优化、降低代码可读性，实现代码保护。
　　4、图片压缩。针对真实图片情况，舍弃一些相对无关紧要的色彩信息。
【开启gzip】
　　HTTP协议上的GZIP编码是一种用来改进WEB应用程序性能的技术。大流量的WEB站点常常使用GZIP压缩技术来让用户感受更快的速度。这一般是指WWW服务器中安装的一个功能，当有人来访问这个服务器中的网站时，服务器中的这个功能就将网页内容压缩后传输到来访的电脑浏览器中显示出来。一般对纯文本内容可压缩到原大小的40%。
 三）优化网络连接
【使用CDN】
　　CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。
【使用DNS预解析】
　　当浏览器访问一个域名的时候，需要解析一次DNS，获得对应域名的ip地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址。
　　DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度。
　　方法是在 head 标签里面写上几个 link 标签
<link rel="dns-prefecth" href="https://www.google.com">
<link rel="dns-prefecth" href="https://www.google-analytics.com">
　　对以上几个网站提前解析 DNS，由于它是并行的，不会堵塞页面渲染，这样可以缩短资源加载的时间。
【并行连接】
　　由于在HTTP1.1协议下，chrome每个域名的最大并发数是6个。使用多个域名，可以增加并发数。
【持久连接】
　　使用keep-alive或presistent来建立持久连接，持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。
【管道化连接】在HTTP2协议中，可以开启管道化连接，即单条连接的多路复用，每条连接中并发传输多个资源，这里就不需要添加域名来增加并发数了
四）优化资源加载。
【资源加载位置】
　　通过优化资源加载位置，更改资源加载时机，使尽可能快地展示出页面内容，尽可能快地使功能可用。
　　1、CSS文件放在head中，先外链，后本页
　　2、JS文件放在body底部，先外链，后本页
　　3、处理页面、处理页面布局的JS文件放在head中，如babel-polyfill.js文件、flexible.js文件
　　4、body中间尽量不写style标签和script标签
【资源加载时机】
　　1、异步script标签
　　defer:  异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似
　　async: 异步加载，加载完成后立即执行
　　2、模块按需加载
　　在SPA等业务逻辑比较复杂的系统中，需要根据路由来加载当前页面需要的业务模块
　　按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载
　　webpack 提供了两个类似的技术，优先选择的方式是使用符合 ECMAScript 提案 的 import() 语法。第二种则是使用 webpack 特定的 require.ensure
　　3、使用资源预加载preload和资源预读取prefetch
　　preload让浏览器提前加载指定资源，需要执行时再执行，可以加速本页面的加载速度
　　prefetch告诉浏览器加载下一页面可能会用到的资源，可以加速下一个页面的加载速度
　　4、资源懒加载与资源预加载
　　资源延迟加载也称为懒加载，延迟加载资源或符合某些条件时才加载某些资源
　　资源预加载是提前加载用户所需的资源，保证良好的用户体验
　　资源懒加载和资源预加载都是一种错峰操作，在浏览器忙碌的时候不做操作，浏览器空间时，再加载资源，优化了网络性能
 五）减少重绘回流
 【样式设置】
　　1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率
　　2、避免使用CSS表达式，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次
　　3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流
　　4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流
　　5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间
　　6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现
【渲染层】
　　1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围
　　2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流
【DOM优化】
　　1、缓存DOM
const div = document.getElementById('div')
　　由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM
　　2、减少DOM深度及DOM数量
　　HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。
　　3、批量操作DOM
　　由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM
　　4、批量操作CSS样式
　　通过切换class或者使用元素的style.csstext属性去批量操作元素样式
　　5、在内存中操作DOM
　　使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上
　　6、DOM元素离线更新
　　对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作
　　7、DOM读写分离
　　浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行
　　8、事件代理
　　事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件
　　利用事件代理，可以减少内存使用，提高性能及降低代码复杂度
　　9、防抖和节流
　　使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发
　　10、及时清理环境
　　及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存
 六）性能更好的API
 1、用对选择器
　　选择器的性能排序如下所示，尽量选择性能更好的选择器
    复制代码
    id选择器（#myid）
    类选择器（.myclassname）
    标签选择器（div,h1,p）
    相邻选择器（h1+p）
    子选择器（ul > li）
    后代选择器（li a）
    通配符选择器（*）
    属性选择器（a[rel="external"]）
    伪类选择器（a:hover,li:nth-child）
    复制代码
　　2、使用requestAnimationFrame来替代setTimeout和setInterval
　　希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用 setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧
　　3、使用IntersectionObserver来实现图片可视区域的懒加载
　　传统的做法中，需要使用scroll事件，并调用getBoundingClientRect方法，来实现可视区域的判断，即使使用了函数节流，也会造成页面回流。使用IntersectionObserver，则没有上述问题
　　4、使用web worker
　　客户端javascript一个基本的特性是单线程：比如，浏览器无法同时运行两个事件处理程序，它也无法在一个事件处理程序运行的时候触发一个计时器。Web Worker是HTML5提供的一个javascript多线程解决方案，可以将一些大计算量的代码交由web Worker运行，从而避免阻塞用户界面，在执行复杂计算和数据处理时，这个API非常有用
　　但是，使用一些新的API的同时，也要注意其浏览器兼容性
七）webpack优化
【打包公共代码】
　　使用CommonsChunkPlugin插件，将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这会带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件
　　webpack 4 将移除 CommonsChunkPlugin, 取而代之的是两个新的配置项 optimization.splitChunks 和 optimization.runtimeChunk
　　通过设置 optimization.splitChunks.chunks: "all" 来启动默认的代码分割配置项
【动态导入和按需加载】
　　webpack提供了两种技术通过模块的内联函数调用来分离代码，优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure
【剔除无用代码】
　　tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup
　　JS的tree shaking主要通过uglifyjs插件来完成，CSS的tree shaking主要通过purify CSS来实现的
【长缓存优化】
　　1、将hash替换为chunkhash，这样当chunk不变时，缓存依然有效
　　2、使用Name而不是id
　　每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变
　　下面来使用两个插件解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建
【公用代码内联】
　　使用html-webpack-inline-chunk-plugin插件将mainfest.js内联到html文件中
```



十八.http状态码有那些？分别代表是什么意思？

```javascript
100-199 服务器收到请求，需要请求者继续执行操作。 
200-299 用于表示请求成功。 
300-399 重定向,需要进一步的操作以完成请求。 
400-499 客户端错误, 用于指出客户端的错误, 请求包含语法错误或无法完成请求。
				400 语义有误，当前请求无法被服务器理解。
        401 当前请求需要用户验证 
        403 服务器已经理解请求，但是拒绝执行它。
500-599 服务器在处理请求的过程中发生了错误。 
				503 – 服务不可用
```

十九.一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？

```javascript
一）分为4个步骤：
    （1）当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。
    （2）浏览器与远程Web服务器通过TCP三次握手协商来建立一个TCP/IP连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。
    （3）一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。
    （4）此时，Web服务器提供资源服务，客户端开始下载资源。
二）三次握手和四次挥手
  三次握手通俗的说法
  1）Client：嘿，李四，是我，听到了吗？
  2）Server：我听到了，你能听到我的吗?
  3）Client：好的，我们互相都能听到对方的话，我们的通信可以开始了。
  四次挥手通俗的说法
  1）Client：我所有东西都说完了
  2）Server：我已经全部听到了，但是等等我，我还没说完
  3）Server：好了，我已经说完了
  4）Client：好的，那我们的通信结束l
```

二十.重绘和回流（Repaint & Reflow）

```javascript
浏览器渲染过程如下：
一）解析HTML，生成DOM树，解析CSS，生成CSSOM树
二）将DOM树和CSSOM树结合，生成渲染树(Render Tree)（渲染树只渲染可见节点，像script之类的不可见节点不渲染）
 	1、从DOM树的根节点开始遍历每个可见节点。
	2、对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。
	3、根据每个可见节点以及其对应的样式，组合生成渲染树。
三）Layout(回流): 根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）（前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。）
四）Painting(重绘): 根据渲染树以及回流得到的几何信息，得到节点的绝对像素（最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。）
五）Display(展示): 将像素发送给GPU，展示在页面上。（重绘后的“画布”交给GPU去处理）

注意：回流一定会触发重绘，而重绘不一定会回流

```

二十一.Mixin、HOC、Render Props

```javascript
一、mixin
Mixin模式就是一些提供能够被一个或者一组子类简单继承功能的类,意在重用其功能,使用mixin方法将任意对象的任意方法扩展到目标对象上，也就是说采用Mixin方式可以复用状态逻辑、行为逻辑等
你可能会写一个有状态的组件，然后你的同事可能添加一个读取这个组件state的mixin。几个月之后，你可能希望将该state移动到父组件，以便与其兄弟组件共享。你会记得更新这个mixin来读取props而不是state吗？如果此时，其它组件也在使用这个mixin呢？进而导致了许多弊端产生
问题：
	隐式依赖导致依赖关系不透明，维护成本和理解成本迅速攀升：
		难以快速理解组件行为，需要全盘了解所有依赖 Mixin 的扩展行为，及其之间的相互影响
    组价自身的方法和state字段不敢轻易删改，因为难以确定有没有 Mixin 依赖它
    Mixin 也难以维护，因为 Mixin 逻辑最后会被打平合并到一起，很难搞清楚一个 Mixin 的输入输出
	Mixins 引起名称冲突（Mixins cause name clashes）（你在该Mixin定义了getDefaultProps, 另外一个Mixin又定义了同样的名称getDefaultProps, 造成了冲突。）
	Mixins 导致滚雪球式的复杂性。（即使刚开始的时候 mixins 很简单，它们往往随着时间的推移变得复杂）
  Mixin 倾向于增加更多状态，这降低了应用的可预测性，导致复杂度剧增。
所以，React v0.13.0 放弃了 Mixin（继承），转而走向HOC（组合）
```

```javascript
二、HOC高阶组件
高阶组件（HOC）是React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是React API 的一部分，它是一种基于React 的组合特性而形成的设计模式。高阶组件是参数为组件，返回值为新组件的函数。
作用：
1、属性代理
2、反向继承
3、操作所有传入的props
4、通过refs访问到组件实例
5、提取state
6、渲染劫持
缺陷
扩展性限制：HOC 并不能完全替代 Mixin
Ref 传递问题：Ref 被隔断,开发中需要专门去处理
Wrapper Hell：HOC 泛滥，出现 Wrapper Hell
```

```javascript
Render Props
组件不自己定义render函数，而是通过一个名为render的props(所以如果名字为children 也可称为children props) 将外部定义的render函数传入使用
类比 HOC,技术上，二者都基于组件组合机制，Render Props 拥有与 HOC 一样的扩展能力,之所以称之为 Render Props，并不是说只能用来复用渲染逻辑, 而是表示在这种模式下，组件是通过render()组合起来的，类似于 HOC 模式下通过 Wrapper 的render()建立组合关系,形式上，二者非常相像，同样都会产生一层“Wrapper”（EComponent和RP）
缺陷：
	使用繁琐: HOC使用只需要借助装饰器语法通常一行代码就可以进行复用,Render Props无法做到如此简单
	嵌套过深: Render Props虽然摆脱了组件多层嵌套的问题,但是转化为了函数回调的嵌套
```

```javascript
优点：
	React Hooks 解决了 render props的嵌套问题，更加简洁。
	解耦：React Hooks 可以更方便的把UI和状态分离，做到更彻底的解耦。
  Hook 和现有代码可以同时工作，你可以渐进式地使用，无需放弃原有的class组件。
	函数的友好：
  	React Hooks为函数式组件解决了很多的问题
		错综复杂的this指向问题。
		分割在不同生命周期中的逻辑使得代码难以理解和维护。
		代码复用成本高。
缺点：
  额外的学习成本，需要学习Function。
  写法出现了很多的限制。
```

```javascript
怎么避免react hooks的常见问题
1、不要在useEffect里面写太多的依赖项，划分这些依赖项成多个单一功能的useEffect。其实这点是遵循了软件设计的“单一职责模式”。
2、复杂业务的时候，使用Component代替hooks。
```

二十二.你在现在的团队处于什么样的角色，起到了什么明显的作用？

二十三.你认为怎样才是全端工程师（Full Stack developer）？

二十四.介绍一个你最得意的作品吧？

二十五.项目中遇到什么问题？如何解决？

二十六.你的优点是什么？缺点是什么？

二十七.如何管理前端团队?

二十八.最近在学什么？能谈谈你未来3，5年给自己的规划吗？

二十九.说说最近最流行的一些东西吧？常去哪些网站？

